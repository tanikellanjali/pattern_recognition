# -*- coding: utf-8 -*-
"""pat_rec.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RVZdiyhASAqzCRKxC7EhwHAWqTBbzd3d
"""

import pandas as pd
import numpy as np
import torch
import sklearn

from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

import matplotlib.pyplot as plt

df = pd.read_csv('train.csv')

df.head()

df.columns

# Function to find subsequences
def find_subsequences(input_sequence):
    """
    Finds and counts subsequences in a sequence.
    Args:
        input_sequence (list): The sequence to analyze.
    Returns:
        dict: A dictionary containing subsequences as keys and their counts as values.
    """
    subsequences = {}
    for i in range(len(input_sequence)):
        for j in range(i + 1, len(input_sequence) + 1):
            subsequence = tuple(sorted(input_sequence[i:j]))
            subsequences[subsequence] = subsequences.get(subsequence, 0) + 1
    return subsequences

# Function to check if a pattern is repeated
def is_pattern_repeat(longer, shorter):
    """
    Checks if a shorter pattern is repeated in a longer sequence.
    Args:
        longer (list): The longer sequence.
        shorter (list): The shorter sequence.
    Returns:
        bool: True if the shorter pattern is repeated. False otherwise.
    """
    repeat_len = len(longer) // len(shorter)

    if repeat_len * len(shorter) != len(longer):
        return False

    for i in range(repeat_len):
        start = i * len(shorter)
        end = start + len(shorter)
        if longer[start:end] != shorter:
            return False
    return True

# Function to find repeating patterns
def run_functions(input_seq):
    """
    Finds repeating patterns in a sequence.
    Args:
        input_seq (list): The sequence to analyze.
    Returns:
        dict: Filtered subsequences with counts.
    """
    subsequences = find_subsequences(input_seq)
    filtered_subsequences = {k: v for k, v in subsequences.items() if v > 1 and 1 < len(k) < 6}

    cleaned_subsequences = sorted(filtered_subsequences)
    for i in range(len(cleaned_subsequences) - 1):
        cur_pat = cleaned_subsequences[i]
        for j in range(i + 1, len(cleaned_subsequences)):
            pat = cleaned_subsequences[j]
            if is_pattern_repeat(pat, cur_pat):
                filtered_subsequences.pop(pat, None)

    return filtered_subsequences

# Encode categorical columns
label_encoders = {}
encoded_data = df.copy()

for col in df.columns:
    le = LabelEncoder()
    encoded_data[col] = le.fit_transform(df[col])
    label_encoders[col] = le

# Analyze patterns for each column
output_patterns = []

for col in df.columns:
    print(f"Analyzing patterns for {col}...")
    patterns = run_functions(encoded_data[col].tolist())
    print(patterns)  # Debugging to see patterns
    decoded_patterns = []
    for pattern, count in patterns.items():
        try:
            decoded = label_encoders[col].inverse_transform(list(pattern))
            decoded_str = " -> ".join(map(str, decoded))  # Convert to string
            decoded_patterns.append({
                "Column": col,
                "Pattern": decoded_str,
                "Frequency": count
            })
        except ValueError as e:
            print(f"Skipping pattern {pattern} for column {col} due to error: {e}")
    print(decoded_patterns)  # Debugging to check output
    output_patterns.extend(decoded_patterns)

# Preprocessing
df["LoanAmount"].fillna(df["LoanAmount"].median(), inplace=True)
categorical_cols = ["Gender", "Married", "Education", "Self_Employed", "Property_Area", "Loan_Status"]
label_encoders = {col: LabelEncoder() for col in categorical_cols}
for col in categorical_cols:
    df[col] = label_encoders[col].fit_transform(df[col])

numeric_cols = ["ApplicantIncome", "CoapplicantIncome", "LoanAmount", "Loan_Amount_Term", "Credit_History"]
scaler = StandardScaler()
df[numeric_cols] = scaler.fit_transform(df[numeric_cols])

# Pattern Recognition
for col in df.columns:
    if col not in ["Loan_ID", "Loan_Status"]:
        print(f"Patterns for {col}:")
        patterns = run_functions(df[col].tolist())
        print(patterns)

# Prediction Model
X = df.drop(columns=["Loan_ID", "Loan_Status"])
y = df["Loan_Status"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
clf = RandomForestClassifier(random_state=42)
clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)
print("\nClassification Report:")
print(classification_report(y_test, y_pred))
print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))
print("\nAccuracy Score:")
print(accuracy_score(y_test, y_pred))